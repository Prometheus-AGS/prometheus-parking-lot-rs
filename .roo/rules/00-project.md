# Prometheus Parking Lot â€” workspace rules

- Purpose: runtime-agnostic parking-lot scheduler for AI/agent workloads; enforce resource-aware scheduling, queue overflow work, wake tasks when capacity frees, and deliver results via mailbox for late pickup. Source context: `CLAUDE.md`, `docs/ARCHITECTURE.md`, `docs/Comprehensive Architectural Report Distributed Parking Management Systems and High-Performance Rust Audit Infrastructur.md`, `docs/DISCUSSION.md`, specs/plans in `docs/`.
- Core architecture (ports/adapters): keep core logic pure; adapters supply infra. Primary abstractions: `ResourcePool` (scheduling/parking), `TaskQueue` (in-memory, Postgres custom table, Postgres/pgmq, Yaque), `Mailbox` (in-memory or SeaORM Postgres storage + optional HTTP notifier), `TaskExecutor` (user logic), builder/config layer (`SchedulerConfig`) to wire pools from JSON/YAML.
- Resource model: tasks carry `TaskMetadata` with `TaskId`, `Priority`, `ResourceCost { kind: Cpu|GpuVram|Io|Mixed, units }`, optional deadline, mailbox ref. Admission rule: if `active_units + cost <= max_units` run immediately; otherwise enqueue in priority queue (FIFO per priority). On task finish, wake the next queued task that fits. Prune/mark expired tasks.
- Environments: support desktop/Tauri (Yaque + local storage), cloud (Postgres/pgmq + Postgres mailbox + HTTP callbacks), and dev/test (in-memory queue/mailbox). Keep scheduling logic runtime-agnostic (no Tokio in core); runtime-specific code lives in adapters.
- Data/infra notes: Postgres tables `pl_queue_jobs` and `pl_mailbox_messages` (see `CLAUDE.md`) with SeaORM models; respect configured queue/mailbox limits, default timeouts, and max queue depth.
- Coding constraints: stay within clean architecture boundaries; avoid leaking infra details into core types; prefer trait-driven design and serde-friendly config structs. Keep rule files concise; do not exceed ~500 lines; split future rules by domain if they grow.
- Testing/quality: favor deterministic unit tests around scheduler invariants (capacity checks, wake ordering, mailbox delivery) and integration smoke tests per backend where feasible.
